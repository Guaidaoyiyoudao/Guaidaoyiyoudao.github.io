[{"title":"二叉树leetcode题解","url":"/2022/07/31/二叉树leetcode题解/","content":"\n\n# Path Sum 路径和\n\nGiven the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\n\nA leaf is a node with no children.\n\n大概的意思就是给一个树，以及一个值，是否存在从树的根到树的叶子节点的值的和等于这个值\n\n## 思路\n\n实际上只需要知道怎么遍历这个二叉树，思路就有了，对于这道题，因为需要从根节点到叶子节点的和，所以采用树的前序遍历就很符合题意\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n       // \n       if( root == nullptr ){\n            return false;\n       } \n\n       return preOrder( root, targetSum );\n\n    }\n    bool preOrder(TreeNode* root, int targetSum ){\n        // 当前叶子节点是空的，那肯定false\n        if( root == nullptr ){\n            return false;\n        }\n        // 如果这个节点没有子节点，那就是叶子节点了\n        // 并且已经满足所有值加起来等于targetSum了\n        // 证明找到了\n        if( root->left == nullptr && root->right == nullptr ){\n            if( targetSum - root->val == 0 ){\n                return true;\n            }\n        }\n        // 减去当前节点的值\n        int curValue = targetSum - root->val;\n        // 只有左子节点或者右子节点有一个满足就true\n        return preOrder( root->left, curValue ) || preOrder( root->right, curValue );\n    }\n};\n\n```\n\n\n\n# Path Sum 2\n\nGiven the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\n\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\n\n这个是路径和1的变种，需要把每条路径值放到一个vector里保存起来，最终返回的结果是每个满足条件的路径\n\n\n## 思路\n\n思路和上面的Path sum1 是一样的，这里就不细说了，主要需要注意的是细节上面的处理\n\n\n## 代码\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<vector<int>> result;\n        if( root == nullptr ){\n            return result;\n        } \n        vector<int> path;\n        preOrder(root,targetSum,path,result);\n        return result;\n    }\n\n    void preOrder( TreeNode* root, int targetSum, vector<int>& path,vector<vector<int>>& res ){\n        if( root == nullptr ){\n            return;\n        }\n\n        if( root->left == nullptr && root->right == nullptr ){\n            if( targetSum - root->val == 0 ){\n                // 满足条件，先把当前节点的值放进去\n                path.push_back( root->val );\n                // 结果保存这条路径\n                res.push_back(path);\n                // 返回前要把这个叶子节点的值pop出来\n                path.pop_back();\n                return;\n            }\n        }\n\n        int cur = targetSum - root->val;\n        // 把当前的路径放进去\n        path.push_back( root->val );\n        preOrder( root->left, cur, path, res );\n        preOrder( root->right, cur, path, res );\n        // 返回前要把这个叶子节点的值pop出来\n        path.pop_back();\n\n    }\n};\n```\n\n\n# 翻转二叉树\n\n\nGiven the root of a binary tree, invert the tree, and return its root.\n\n给定一个二叉树，翻转一下，然后返回根\n\n## 思路\n\n题目的意图实际上就是交换一下当前节点的左子节点和右子节点，我们只需要分别遍历节点，然后交换一下就好了。\n\n还是需要知道二叉树的遍历方式\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if( root == nullptr ){\n            return nullptr;\n        } \n        swapTree( root );\n        return root;\n    }\n    void swapTree( TreeNode* root ){\n        if( root == nullptr ){\n            return;\n        }\n        // 交换一下\n        std::swap( root->left, root->right );\n        // 左子节点和右子节点都一样\n        swapTree( root->left );\n        swapTree( root->right );\n    }\n};\n\n```\n","tags":["leetcode","二叉树"]},{"title":"二叉树遍历方法","url":"/2022/07/30/二叉树遍历方法/","content":"\n# 二叉树的遍历方法\n\n二叉树的遍历方法有三种方法：\n- 前序遍历\n- 中序遍历\n- 后序遍历\n\n因此，对二叉树的序列化和反序列化可采用上述三种方法\n\n## 前序遍历\n\n前序遍历的顺序为\n1. 先根节点\n2. 再左节点\n3. 后右节点\n\n{% asset_img 前序遍历示意图.png 前序遍历示意图 %}\n\n前序遍历的迭代和递归代码如下\n```c++\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if( root == nullptr ){\n            return result;\n        }\n        // 迭代版本前序遍历\n        stack<TreeNode*> preOrder_stack;\n        preOrder_stack.push(root);\n        while( !preOrder_stack.empty() ){\n            TreeNode* node = preOrder_stack.top();\n            preOrder_stack.pop();\n            // 先根\n            result.push_back( node->val );\n            // 后右\n            if( node->right != nullptr ){\n                preOrder_stack.push( node->right );\n            }\n            // 再左\n            if( node->left != nullptr ){\n                preOrder_stack.push( node->left );\n            }\n            \n        }\n\n        // 递归版本前序遍历\n        // preOrder( result, root );\n\n        return result;\n    }\n    void preOrder( vector<int>& res, TreeNode* root ){\n        if( root == nullptr ){\n            return;\n        }\n        res.push_back( root->val );\n        preOrder( res, root->left );\n        preOrder( res, root->right );\n    }\n};\n```\n\n## 中序遍历\n\n中序遍历的顺序为，\n1. 先左节点\n2. 再根节点\n3. 后右节点\n\n{% asset_img 中序遍历示意图.png 中序遍历示意图 %}\n\n当我们使用中序遍历这个二叉树的时候，输出则为\n\n`[1,2,3,4,5,7]`\n\n中序遍历的代码如下，分为了迭代遍历以及递归遍历  \n*注意下，这里的迭代遍历有内存泄露*\n\n```c++\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if( root == nullptr ){\n            return result;\n        }\n        stack<TreeNode*> inorder_stack;\n        inorder_stack.push( root );\n        while( !inorder_stack.empty() ){\n            TreeNode* top_node = inorder_stack.top();\n            // 左先处理\n            if( top_node->left != nullptr ){\n                inorder_stack.push( top_node->left );\n                top_node->left = nullptr;\n                continue;\n            }\n            // 根\n            result.push_back( top_node->val );\n            inorder_stack.pop();\n            // 右子树\n            if( top_node->right != nullptr ){\n                inorder_stack.push( top_node->right );\n            }\n\n        }\n\n        return result;\n    }\n    void InOrder( vector<int>& res, TreeNode* root  ){\n        if( root == nullptr )\n            return;\n        InOrder( res, root->left );\n        res.push_back( root->val );\n        InOrder( res, root->right );\n\n    }\n\n\n};\n\n```\n## 后序遍历\n\n后续遍历的顺序则为\n1. 先左节点\n2. 再右节点\n3. 后根节点\n\n后序遍历图示\n{% asset_img 后序遍历示意图.png 后序遍历示意图 %}\n\n迭代和递归版本的后序遍历代码：\n```c++\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if( root == nullptr ){\n            return result;\n        }\n        stack<TreeNode*> postOrder_stack;\n        postOrder_stack.push( root );\n        while( !postOrder_stack.empty() ){\n            TreeNode* node = postOrder_stack.top();\n            bool has_son = false;\n            // 2.再右子节点\n            if( node->right != nullptr ){\n                postOrder_stack.push( node->right );\n                node->right = nullptr;\n                has_son = true;\n            }\n            // 1.先左\n            if( node->left != nullptr ){\n                postOrder_stack.push( node->left );\n                node->left = nullptr;\n                has_son = true;\n            }\n            // 3.根最后遍历\n            if( has_son ){\n                continue;\n            }\n            result.push_back( node->val );\n            postOrder_stack.pop();\n            // delete node\n        }\n        // 递归版本后序遍历\n        // postOrder( result, root );\n\n        return result;\n    }\n    void postOrder( vector<int>& res, TreeNode* root ){\n        if( root == nullptr ){\n            return;\n        }\n        postOrder( res, root->left );\n        postOrder( res, root->right );\n        res.push_back( root->val );\n    }\n};\n```\n\n# 总结\n\n可以看到，在对树的遍历方法上，递归遍历的代码十分简单，理解起来也比较容易，而迭代版本则相对来说复杂。通常来说，对于树的相关操作，递归版本的代码都要比迭代版本的代码简单。","tags":["leetcode","二叉树"]},{"title":"设计模式-状态模式","url":"/2022/07/19/设计模式-状态模式/","content":"\n\n# 状态模式\n\n## 动机\n\n在软件构建过程中，某些对象的状态发生变化，其行为也会随之而发生变化。\n\n## 定义\n\n允许一个对象在其内部状态发生改变时改变它的行为，从而使对象看起来似乎修改了其行为。\n\n## 代码示例\n\n### 坏代码\n\n假设我们的网络有三种状态\n```c++\nenum NetworkState\n{\n    Network_Open,\n    Network_Close,\n    Network_Connect\n};\n```\n同时，我们有一个网络的应用，其中保存了网络的状态，那么当我们的状态发生变化的时候，这个应用的行为应该是不一样的\n```c++\nclass NetworkProcesser\n{\nprivate:\n    NetworkState m_state;\n\npublic:\n\n    // 这里有一个操作，需要对网络操作的状态进行判断\n    void operation1()\n    {\n        if( state == Network_Open ){\n            //..\n            m_state = Network_Close;\n        }else if( state == Network_Close ){\n            // ..\n            m_state = Network_Connect;\n        }else if( state == Network_Connect ){\n            // ...\n            m_state = Network_Open;\n        }\n        \n    }\n};\n```\n其实，可以看到这里的`if-else`针对我们的网络状态做了不同的变化，这里状态只有三个的时候，用了三个`if-else`去这么做没啥问题，但是当我们的网络状态出现新增的状态的时候，需要怎么更改呢？难道新增一个`else-if`分支？这样子违反了**开闭原则**\n\n### 好代码\n\n","tags":["设计模式"]},{"title":"Reactor网络框架","url":"/2022/07/18/Reactor网络框架/"},{"title":"libevent源码阅读篇(一)","url":"/2022/07/17/libevent源码阅读篇-一/","content":"\n# libevent使用\n\n在了解libevent的源码之前，首先看一下libevent的基本使用方法\n\n## libevent版HelloWorld\n\n`libevent`有两个比较重要的结构体\n- `event`\n- `event_base`\n\n其中，`event`结构体用来存放诸如`fd`以及回调函数等，结构体定义：\n```c\n\n```\n\n`event_base`是整个libevent库的核心\n\n","tags":["网络编程","源码分析","libevent"],"categories":["libevent"]},{"title":"socket基础","url":"/2022/07/17/socket/","content":"\n# socket\n\n## 服务端\n\n服务端的编程大致如下：\n```c++\nsocket()\nbind()\nlisten()\naccept()\n```\n### socket()\n\nsocket用于创建一个套接字，有三个参数\n- famility\n    - 协议族，基本是都用`AF_INET`\n- protocol\n    - 协议，要么TCP:`SOCKET_STREAM`或者UDP:`SOCKET_DGRAM`","tags":["网络编程","linux"]},{"title":"Hello World","url":"/2022/07/17/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]