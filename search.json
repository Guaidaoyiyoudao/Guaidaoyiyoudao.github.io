[{"title":"二叉树遍历方法","url":"/2022/07/30/二叉树遍历方法/","content":"\n# 二叉树的遍历方法\n\n二叉树的遍历方法有三种方法：\n- 前序遍历\n- 中序遍历\n- 后序遍历\n\n因此，对二叉树的序列化和反序列化可采用上述三种方法\n\n## 前序遍历\n\n前序遍历的顺序为\n1. 先根节点\n2. 再左节点\n3. 后右节点\n\n{% asset_img 前序遍历示意图.png 前序遍历示意图 %}\n\n## 中序遍历\n\n中序遍历的顺序为，\n1. 先左节点\n2. 再根节点\n3. 后右节点\n\n{% asset_img 中序遍历示意图.png 中序遍历示意图 %}\n\n当我们使用中序遍历这个二叉树的时候，输出则为\n\n`[1,2,3,4,5,7]`\n\n中序遍历的代码如下，分为了迭代遍历以及递归遍历  \n*注意下，这里的迭代遍历有内存泄露*\n\n```c++\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if( root == nullptr ){\n            return result;\n        }\n        stack<TreeNode*> inorder_stack;\n        inorder_stack.push( root );\n        while( !inorder_stack.empty() ){\n            TreeNode* top_node = inorder_stack.top();\n            // 左先处理\n            if( top_node->left != nullptr ){\n                inorder_stack.push( top_node->left );\n                top_node->left = nullptr;\n                continue;\n            }\n            // 根\n            result.push_back( top_node->val );\n            inorder_stack.pop();\n            // 右子树\n            if( top_node->right != nullptr ){\n                inorder_stack.push( top_node->right );\n            }\n\n        }\n\n        return result;\n    }\n    void InOrder( vector<int>& res, TreeNode* root  ){\n        if( root == nullptr )\n            return;\n        InOrder( res, root->left );\n        res.push_back( root->val );\n        InOrder( res, root->right );\n\n    }\n\n\n};\n\n```\n## 后序遍历\n\n后续遍历的顺序则为\n1. 先左节点\n2. 再右节点\n3. 后根节点\n\n","tags":["leetcode","二叉树"]},{"title":"设计模式-状态模式","url":"/2022/07/19/设计模式-状态模式/","content":"\n\n# 状态模式\n\n## 动机\n\n在软件构建过程中，某些对象的状态发生变化，其行为也会随之而发生变化。\n\n## 定义\n\n允许一个对象在其内部状态发生改变时改变它的行为，从而使对象看起来似乎修改了其行为。\n\n## 代码示例\n\n### 坏代码\n\n假设我们的网络有三种状态\n```c++\nenum NetworkState\n{\n    Network_Open,\n    Network_Close,\n    Network_Connect\n};\n```\n同时，我们有一个网络的应用，其中保存了网络的状态，那么当我们的状态发生变化的时候，这个应用的行为应该是不一样的\n```c++\nclass NetworkProcesser\n{\nprivate:\n    NetworkState m_state;\n\npublic:\n\n    // 这里有一个操作，需要对网络操作的状态进行判断\n    void operation1()\n    {\n        if( state == Network_Open ){\n            //..\n            m_state = Network_Close;\n        }else if( state == Network_Close ){\n            // ..\n            m_state = Network_Connect;\n        }else if( state == Network_Connect ){\n            // ...\n            m_state = Network_Open;\n        }\n        \n    }\n};\n```\n其实，可以看到这里的`if-else`针对我们的网络状态做了不同的变化，这里状态只有三个的时候，用了三个`if-else`去这么做没啥问题，但是当我们的网络状态出现新增的状态的时候，需要怎么更改呢？难道新增一个`else-if`分支？这样子违反了**开闭原则**\n\n### 好代码\n\n","tags":["设计模式"]},{"title":"Reactor网络框架","url":"/2022/07/18/Reactor网络框架/"},{"title":"libevent源码阅读篇(一)","url":"/2022/07/17/libevent源码阅读篇-一/","content":"\n# libevent使用\n\n在了解libevent的源码之前，首先看一下libevent的基本使用方法\n\n## libevent版HelloWorld\n\n`libevent`有两个比较重要的结构体\n- `event`\n- `event_base`\n\n其中，`event`结构体用来存放诸如`fd`以及回调函数等，结构体定义：\n```c\n\n```\n\n`event_base`是整个libevent库的核心\n\n","tags":["网络编程","源码分析","libevent"],"categories":["libevent"]},{"title":"socket基础","url":"/2022/07/17/socket/","content":"\n# socket\n\n## 服务端\n\n服务端的编程大致如下：\n```c++\nsocket()\nbind()\nlisten()\naccept()\n```\n### socket()\n\nsocket用于创建一个套接字，有三个参数\n- famility\n    - 协议族，基本是都用`AF_INET`\n- protocol\n    - 协议，要么TCP:`SOCKET_STREAM`或者UDP:`SOCKET_DGRAM`","tags":["网络编程","linux"]},{"title":"Hello World","url":"/2022/07/17/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]